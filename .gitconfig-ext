[alias]
  # add
  a = "add"
  aa = "!f() { git add -A; git status; }; f"

  # branch
	bb = !~/code/rcfiles/scripts/better-git-branch.sh
	bl = !~/code/rcfiles/scripts/git-branch-list.sh
	branch-clean = !~/code/rcfiles/scripts/git-branch-clean.py

  create-branch = "!f() { branch=jeff.lai/$1; if git show-ref --verify --quiet \"refs/heads/$branch\"; then echo \"Branch $branch already exists\"; elif git show-ref --verify --quiet \"refs/remotes/origin/$branch\"; then git branch \"$branch\" \"origin/$branch\"; else git branch \"$branch\" HEAD && git branch --edit-description \"$branch\"; fi; }; f"

  stack-branch = "!f() { current=$(git branch --show-current); if [[ $current =~ -p([0-9]+)$ ]]; then new_number=$((${BASH_REMATCH[1]} + 1)); new_branch=${current%-p*}-p$new_number; else new_branch=\"$current-p1\"; fi; git checkout -b $new_branch; git branch --edit-description; }; f"

  new-branch = "!f() { default=$(git rev-parse --abbrev-ref origin/HEAD | cut -c8-) && git fetch origin $default && branch=jeff.lai/$1; if git show-ref --verify --quiet \"refs/heads/$branch\"; then echo \"Branch $branch already exists\" && git checkout \"$branch\"; elif git show-ref --verify --quiet \"refs/remotes/origin/$branch\"; then git branch \"$branch\" \"origin/$branch\" && git checkout \"$branch\"; else git branch \"$branch\" origin/$default && git branch --edit-description \"$branch\" && git checkout \"$branch\"; fi; }; f"

  current-branch = "!f() { branch=$(git rev-parse --abbrev-ref HEAD) && echo $branch | pbcopy && echo $branch; }; f"

  branch-cleanup = "!git for-each-ref --format='%(refname:short)' refs/heads | rg -wv \"main|libevp-staging|jeff\\.lai.*\" | xargs git branch -D"

  # checkout
  cob = "!f() { git fetch origin $1 && git checkout -b $1 origin/$1; }; f"
  co = "checkout"

  # commit
  fixup = "!git log --author=\"Jeff Lai\" --pretty=format:'%h [%ae] %s' --no-merges -n 10 | rg -v fixup | fzf | cut -c -7 | xargs -o git commit -e --fixup"
  cf = "!f() { git commit -a --fixup=$1; }; f"

  # diff
  d = diff

  pull-head = "!git fetch origin $(git rev-parse --abbrev-ref HEAD) && git pull origin $(git rev-parse --abbrev-ref HEAD)"

  # log
  l = log
  ll = log --oneline

  focus = "!$DATADOG_ROOT/experimental/teams/language-tools/bin/git-focus"

  # status
  s = status

  # reset
  reset-remote = "!git fetch origin $(git rev-parse --abbrev-ref HEAD) && git reset --hard @{u}"

  # rebase
  rebase-remote = "!git fetch origin $(git rev-parse --abbrev-ref HEAD) && git rebase @{u}"
  rebase-latest = "!f() { default=$(git rev-parse --abbrev-ref origin/HEAD | cut -c8-) && git fetch origin $default:$default && git rebase $default; }; f"

  wip = "!git commit -m 'WIP' --no-verify"
  awip = "!git add -A && git wip"




# From: https://blog.gitbutler.com/how-git-core-devs-configure-git/

# clearly makes git better
[column]
        ui = auto
[branch]
        sort = -committerdate
[tag]
        sort = version:refname
[init]
        defaultBranch = main
[diff]
        algorithm = histogram
        colorMoved = plain
        mnemonicPrefix = true
        renames = true
[push]
        default = simple
        autoSetupRemote = true
        followTags = true
[fetch]
        prune = true
        pruneTags = true
        all = true

# why the hell not?

[help]
        autocorrect = prompt
[commit]
        verbose = true
[rerere]
        enabled = true
        autoupdate = true
[core]
        excludesfile = ~/.gitignore
[rebase]
        autoSquash = true
        autoStash = true
        updateRefs = true
